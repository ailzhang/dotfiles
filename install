#!/usr/bin/env bash
#
# Dotfiles installation script
# Supports macOS and Linux (apt/dnf, falls back to Homebrew)
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------

info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

die() {
    error "$1"
    exit 1
}

command_exists() {
    command -v "$1" &>/dev/null
}

# Create symlink, backing up existing file if necessary
link_file() {
    local src="$1"
    local dest="$2"

    if [[ ! -e "$src" ]]; then
        warn "Source does not exist: $src"
        return 1
    fi

    if [[ -L "$dest" ]]; then
        local current_target
        current_target=$(readlink "$dest")
        if [[ "$current_target" == "$src" ]]; then
            success "Already linked: $dest"
            return 0
        fi
        warn "Removing existing symlink: $dest -> $current_target"
        rm "$dest"
    elif [[ -e "$dest" ]]; then
        local backup="${dest}.backup.$(date +%Y%m%d%H%M%S)"
        warn "Backing up existing file: $dest -> $backup"
        mv "$dest" "$backup"
    fi

    mkdir -p "$(dirname "$dest")"
    ln -s "$src" "$dest"
    success "Linked: $dest -> $src"
}

# -----------------------------------------------------------------------------
# OS Detection
# -----------------------------------------------------------------------------

detect_os() {
    case "$(uname -s)" in
        Darwin)
            OS="macos"
            ;;
        Linux)
            OS="linux"
            ;;
        *)
            die "Unsupported operating system: $(uname -s)"
            ;;
    esac
    info "Detected OS: $OS"
}

# Detect if running on a Facebook devserver
is_fb_devserver() {
    local hostname
    hostname=$(hostname -f 2>/dev/null || hostname)
    # Match common FB devserver patterns: devvm, devbig, devgpu, sandcastle, etc.
    if [[ "$hostname" =~ \.(facebook|fb)\.com$ ]] || [[ "$hostname" =~ ^dev[a-z]+[0-9]+ ]]; then
        return 0
    fi
    return 1
}

# -----------------------------------------------------------------------------
# FB Devserver Proxy Setup
# -----------------------------------------------------------------------------

PROXY_ENV=""

setup_fwdproxy() {
    if ! is_fb_devserver; then
        return 0
    fi

    info "Setting up fwdproxy for FB devserver..."

    # Check if fwdproxy is available
    if ! command_exists fwdproxy; then
        die "fwdproxy is not available. Please install it first:\n  sudo feature install ttls_fwdproxy\n  systemctl --user start ttls_fwdproxy_root_loader.service\n\nThen set up the proxy alias:\n  alias with-proxy='HTTPS_PROXY=http://fwdproxy:8080 HTTP_PROXY=http://fwdproxy:8080 FTP_PROXY=http://fwdproxy:8080 https_proxy=http://fwdproxy:8080 http_proxy=http://fwdproxy:8080 ftp_proxy=http://fwdproxy:8080 no_proxy=*.facebook.com,*.tfbnw.net,*.fb.com'"
    fi

    # Set proxy environment for this script
    PROXY_ENV="HTTPS_PROXY=http://fwdproxy:8080 HTTP_PROXY=http://fwdproxy:8080 FTP_PROXY=http://fwdproxy:8080 https_proxy=http://fwdproxy:8080 http_proxy=http://fwdproxy:8080 ftp_proxy=http://fwdproxy:8080 no_proxy='*.facebook.com,*.tfbnw.net,*.fb.com'"

    success "fwdproxy configured"
}

# Run curl with proxy if on FB devserver
proxy_curl() {
    if [[ -n "$PROXY_ENV" ]]; then
        env $PROXY_ENV curl "$@"
    else
        curl "$@"
    fi
}

# -----------------------------------------------------------------------------
# Package Installation
# -----------------------------------------------------------------------------

install_packages() {
    info "Installing system packages..."

    case "$OS" in
        macos)
            if ! command_exists brew; then
                info "Installing Homebrew..."
                /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            fi
            brew install curl zsh ncdu cmake neovim || true
            ;;
        linux)
            if is_fb_devserver; then
                # neovim already installed on FB devservers
                sudo dnf install -y curl zsh xclip ncdu cmake gcc-c++ make
                # Link vi to nvim
                if command_exists nvim && ! command_exists vi; then
                    sudo ln -sf "$(command -v nvim)" /usr/local/bin/vi
                fi
            else
                sudo apt update
                sudo apt install -y curl zsh xclip ncdu cmake build-essential neovim
            fi
            ;;
    esac

    success "System packages installed"
}

# -----------------------------------------------------------------------------
# Miniconda Installation
# -----------------------------------------------------------------------------

install_miniconda() {
    local miniconda_dir="$HOME/miniconda3"

    if [[ -d "$miniconda_dir" ]]; then
        success "Miniconda already installed at $miniconda_dir"
        return 0
    fi

    info "Installing Miniconda..."

    local installer
    local url

    case "$OS" in
        macos)
            case "$(uname -m)" in
                arm64)
                    url="https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh"
                    ;;
                *)
                    url="https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh"
                    ;;
            esac
            ;;
        linux)
            case "$(uname -m)" in
                aarch64)
                    url="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh"
                    ;;
                *)
                    url="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh"
                    ;;
            esac
            ;;
    esac

    installer="$(mktemp).sh"
    proxy_curl -fsSL "$url" -o "$installer"
    bash "$installer" -b -p "$miniconda_dir"
    rm -f "$installer"

    success "Miniconda installed at $miniconda_dir"
}

# -----------------------------------------------------------------------------
# Oh My Zsh Installation
# -----------------------------------------------------------------------------

install_oh_my_zsh() {
    if [[ -d "$HOME/.oh-my-zsh" ]]; then
        success "Oh My Zsh already installed"
        return 0
    fi

    info "Installing Oh My Zsh..."
    # Use --unattended to avoid the installer changing the shell and starting zsh
    sh -c "$(proxy_curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
    success "Oh My Zsh installed"
}

# -----------------------------------------------------------------------------
# Git Submodules
# -----------------------------------------------------------------------------

init_submodules() {
    info "Initializing git submodules..."
    cd "$DOTFILES_DIR"
    git submodule update --init --recursive
    success "Git submodules initialized"
}

# -----------------------------------------------------------------------------
# Symlink Dotfiles
# -----------------------------------------------------------------------------

setup_dotfiles() {
    info "Setting up dotfiles..."

    # Shell configuration
    link_file "$DOTFILES_DIR/.zshrc" "$HOME/.zshrc"
    link_file "$DOTFILES_DIR/.zsh" "$HOME/.zsh"

    # Git configuration
    link_file "$DOTFILES_DIR/.gitconfig" "$HOME/.gitconfig"

    # Tmux configuration
    link_file "$DOTFILES_DIR/.tmux.conf" "$HOME/.tmux.conf"

    success "Dotfiles linked"
}

# -----------------------------------------------------------------------------
# Claude Code Configuration
# -----------------------------------------------------------------------------

setup_claude() {
    info "Setting up Claude Code configuration..."

    mkdir -p "$HOME/.claude"

    link_file "$DOTFILES_DIR/CLAUDE_global.md" "$HOME/.claude/CLAUDE.md"
    link_file "$DOTFILES_DIR/claude_settings.json" "$HOME/.claude/settings.json"
    link_file "$DOTFILES_DIR/claude_commands" "$HOME/.claude/commands"
    link_file "$DOTFILES_DIR/skills" "$HOME/.claude/skills"
    link_file "$DOTFILES_DIR/rules" "$HOME/.claude/rules"

    success "Claude Code configuration linked"
}

# -----------------------------------------------------------------------------
# Neovim Setup
# -----------------------------------------------------------------------------

setup_vim() {
    info "Setting up Neovim..."

    # Set up Neovim config directory
    local nvim_config_dir="$HOME/.config/nvim"
    mkdir -p "$nvim_config_dir"

    # Link init.lua for Neovim (modern Lua config)
    link_file "$DOTFILES_DIR/nvim/init.lua" "$nvim_config_dir/init.lua"
    link_file "$DOTFILES_DIR/colors" "$nvim_config_dir/colors"

    # Install Neovim plugins using lazy.nvim (auto-bootstraps)
    if command_exists nvim; then
        info "Installing Neovim plugins via lazy.nvim (this may take a moment)..."
        nvim --headless "+Lazy! sync" +qa 2>/dev/null || warn "Neovim plugin installation had issues"
        success "Neovim plugins installed"
    fi
}

# -----------------------------------------------------------------------------
# fzf Shell Integration
# -----------------------------------------------------------------------------

setup_fzf() {
    info "Setting up fzf shell integration..."

    local fzf_dir="$HOME/.vim/bundle/.fzf"
    if [[ -d "$fzf_dir" ]]; then
        # Source fzf in zshrc if not already present
        if ! grep -q "fzf.zsh" "$HOME/.zshrc" 2>/dev/null; then
            info "Adding fzf shell integration to .zshrc..."
            cat >> "$HOME/.zshrc" << 'EOF'

# fzf shell integration
[ -f ~/.vim/bundle/.fzf/shell/completion.zsh ] && source ~/.vim/bundle/.fzf/shell/completion.zsh
[ -f ~/.vim/bundle/.fzf/shell/key-bindings.zsh ] && source ~/.vim/bundle/.fzf/shell/key-bindings.zsh
EOF
            success "fzf shell integration added"
        else
            success "fzf shell integration already configured"
        fi
    else
        warn "fzf not found at $fzf_dir - run 'vim +PlugInstall' first"
    fi
}

# -----------------------------------------------------------------------------
# Change Default Shell
# -----------------------------------------------------------------------------

change_shell() {
    if [[ "$SHELL" == *"zsh"* ]]; then
        success "Zsh is already your default shell"
        return 0
    fi

    local zsh_path
    zsh_path=$(command -v zsh)

    if [[ -z "$zsh_path" ]]; then
        warn "Zsh not found, skipping shell change"
        return 1
    fi

    info "Changing default shell to zsh..."

    # Ensure zsh is in /etc/shells
    if ! grep -q "$zsh_path" /etc/shells 2>/dev/null; then
        warn "Adding $zsh_path to /etc/shells (requires sudo)"
        echo "$zsh_path" | sudo tee -a /etc/shells >/dev/null
    fi

    chsh -s "$zsh_path"
    success "Default shell changed to zsh (restart terminal to take effect)"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    echo ""
    echo -e "${BLUE}======================================${NC}"
    echo -e "${BLUE}     Dotfiles Installation Script     ${NC}"
    echo -e "${BLUE}======================================${NC}"
    echo ""

    detect_os
    setup_fwdproxy
    install_packages
    install_miniconda
    install_oh_my_zsh
    init_submodules
    setup_dotfiles
    setup_claude
    setup_vim
    setup_fzf
    change_shell

    echo ""
    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}     Installation Complete!          ${NC}"
    echo -e "${GREEN}======================================${NC}"
    echo ""
    info "Please restart your terminal or run: exec zsh"
    echo ""
}

main "$@"
